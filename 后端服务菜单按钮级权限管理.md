主题：白色

# 后端服务菜单按钮级权限管理

## 概述
本文档说明如何在后端实现菜单与按钮级别（精细到前端按钮）权限控制，面向 Spring Boot 项目。目标是：
- 支持菜单（页面/路由）与按钮（页面内操作）级别权限管理
- 支持角色聚合权限、用户直接赋权
- 支持按页面一次性下发前端按钮集合
- 后端接口对敏感操作强制权限校验
- 基于数据库存储权限并使用 Redis 缓存以保证性能

## 设计原则
- 权限采用字符串表达（namespace:resource:action），便于在代码和前端中比对
- 前端只负责显示/隐藏按钮，最终权限需在后端再次校验
- 角色优先、用户直赋权可覆盖/追加
- 权限变更应支持即时生效（通过缓存失效或消息通知）

## 权限字符串约定
- 格式：{module}:{menuCode}:{action}
  - module：业务模块标识（例如 order, user, admin）
  - menuCode：菜单或页面的唯一编码（例如 order-list）
  - action：按钮/操作（例如 view, add, edit, delete, export）

示例：
- order:order-list:add
- user:user-detail:delete

## 数据模型（示例 DDL）
以下为 MySQL 示例建表 SQL：

-- 权限表（每一行代表一个可被分配的权限/按钮）
CREATE TABLE `permission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `code` varchar(128) NOT NULL COMMENT '权限标识，如 order:order-list:add',
  `name` varchar(128) NOT NULL COMMENT '中文名，如 订单列表-新增',
  `module` varchar(64) DEFAULT NULL,
  `menu_code` varchar(128) DEFAULT NULL,
  `action` varchar(64) DEFAULT NULL,
  `url` varchar(256) DEFAULT NULL COMMENT '后端接口路径（可选）',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_permission_code` (`code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 角色表
CREATE TABLE `role` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(128) NOT NULL,
  `code` varchar(64) NOT NULL,
  `description` varchar(255) DEFAULT NULL,
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_role_code` (`code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 角色-权限关联
CREATE TABLE `role_permission` (
  `role_id` bigint NOT NULL,
  `permission_id` bigint NOT NULL,
  PRIMARY KEY(`role_id`,`permission_id`),
  KEY `idx_permission_id` (`permission_id`),
  CONSTRAINT `fk_rp_role` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_rp_permission` FOREIGN KEY (`permission_id`) REFERENCES `permission` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 用户表（示例，项目已有用户表则关联）
CREATE TABLE `user_account` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(128) NOT NULL,
  `password` varchar(256) NOT NULL,
  `enabled` tinyint(1) DEFAULT 1,
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 用户-角色关联
CREATE TABLE `user_role` (
  `user_id` bigint NOT NULL,
  `role_id` bigint NOT NULL,
  PRIMARY KEY(`user_id`,`role_id`),
  KEY `idx_role_id` (`role_id`),
  CONSTRAINT `fk_ur_user` FOREIGN KEY (`user_id`) REFERENCES `user_account` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_ur_role` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 用户-权限直赋（覆盖/追加）可选
CREATE TABLE `user_permission` (
  `user_id` bigint NOT NULL,
  `permission_id` bigint NOT NULL,
  `grant_type` tinyint DEFAULT 1 COMMENT '1=追加,2=覆盖',
  PRIMARY KEY(`user_id`,`permission_id`),
  KEY `idx_up_permission` (`permission_id`),
  CONSTRAINT `fk_up_user` FOREIGN KEY (`user_id`) REFERENCES `user_account` (`id`) ON DELETE CASCADE,
  CONSTRAINT `fk_up_permission` FOREIGN KEY (`permission_id`) REFERENCES `permission` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

## 后端接口契约（REST）
- GET /api/auth/permissions?pageCode={menuCode}&userId={userId}
  - 描述：返回某一页面当前用户可见的按钮权限列表（权限 code 数组）
  - 返回：{"data": ["order:order-list:add","order:order-list:export"]}

- GET /api/admin/permissions
  - 描述：权限列表（管理）

- POST /api/admin/roles
  - 描述：新增角色并绑定权限
  - 入参：{name,code,permissionIds[]}

- PUT /api/admin/roles/{id}
  - 描述：修改角色权限

- POST /api/admin/permissions
  - 描述：新增权限项（页面按钮）
  - 入参：{code,name,module,menuCode,action,url}

- POST /api/admin/permissions/refresh-cache
  - 描述：强制刷新权限缓存（或通过消息通知）

## 权限加载契约
- 登录/鉴权成功后，后端需要加载该用户的所有权限字符串（来自角色->权限与 user_permission）
- 缓存 Key 示例："auth:permissions:user:{userId}" 缓存内容为权限 code 列表
- Token/JWT 中可以只存 userId 与 token 过期，不在 JWT 中存权限列表（避免频繁失效问题）

## 支持用户自定义菜单（统一 action 接口）— 鉴权策略

场景：业务允许用户自定义菜单（例如创建自有页面或快捷方式），这些菜单在后端统一走一套 action 接口（例如 /api/action 执行不同操作），因此无法仅通过 URL 路径做鉴权。

目标：在统一 action 接口下，确保后端能够精确鉴权到按钮/操作级别，并且支持动态（用户自定义）菜单的权限分配。

核心思路：把请求上下文（如 menuId/ menuCode、action 参数、module）解析为标准权限字符串（{module}:{menuCode}:{action}），再基于已有的权限缓存或数据库进行判断。

主要组成：
- 菜单元数据表（menu）保存菜单 id -> menuCode 映射与允许的 action 列表。
- 在统一 action 请求中，前端必须传递标识该菜单/页面的唯一 id（menuId）或 menuCode，以及 action（操作名）。
- 后端根据 menuId 查到 menuCode，再拼装权限 key 并校验（优先查 Redis 缓存，缓存缺失回 DB）。

推荐的流程：
1. 前端调用统一 action 接口时，必须提交 {menuId, action, payload}。menuId 为创建菜单时分配的唯一 id（不可篡改）。
2. 后端在统一入口处做鉴权中间件/过滤器：
   - 解析 token 得到 userId
   - 验证 menuId 的存在性和有效性（查缓存或 menu 表）
   - 从 menu 元数据获取 menuCode 与允许的 action 列表，检查请求 action 是否在允许范围内
   - 拼装权限字符串：permissionKey = module + ':' + menuCode + ':' + action
   - 调用 PermissionService 判断当前用户是否持有该 permissionKey（缓存优先）
   - 若没有权限，返回 403；若有权限，继续执行业务逻辑

防篡改建议：
- menuId 为前端可见的标识，但不能完全信任。建议在 menu 表中保存 owner/creator/tenant 信息并在鉴权时校验所属关系。
- 对于关键操作，可以在前端请求中额外携带 menuVersion 或签名（HMAC），后端验证 menuVersion 与 DB 中的版本一致或校验签名以防止伪造 menuId+action。

数据库扩展建议（新增表）：

-- 用户自定义菜单表（存储 menuId 与 menuCode、meta）
CREATE TABLE `menu` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `menu_code` varchar(128) NOT NULL COMMENT '菜单唯一编码，供权限拼接使用，建议不可修改',
  `name` varchar(128) DEFAULT NULL,
  `module` varchar(64) DEFAULT NULL,
  `owner_user_id` bigint DEFAULT NULL COMMENT '拥有者或租户',
  `version` bigint DEFAULT 0,
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_menu_code` (`menu_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 菜单允许的 action 列表（或可直接存在 menu 的 JSON 字段中）
CREATE TABLE `menu_action` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `menu_id` bigint NOT NULL,
  `action` varchar(64) NOT NULL,
  `name` varchar(128) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_menu_id` (`menu_id`),
  CONSTRAINT `fk_ma_menu` FOREIGN KEY (`menu_id`) REFERENCES `menu` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

说明：在创建自定义菜单时，同时向 `permission` 表插入对应的 permission code（module:menuCode:action），或在首次校验时动态生成并入库（推荐管理员可审核或自动入库）。

伪代码（统一 action 控制器内鉴权逻辑）：

```
function handleActionRequest(request) {
  userId = auth.getUserId(request.token);
  menuId = request.body.menuId;
  action = request.body.action;

  menu = MenuCache.get(menuId);
  if (menu == null) menu = menuRepository.findById(menuId);
  if (menu == null) return 404;

  if (!menu.allowedActions.contains(action)) return 400; // 非法 action

  permissionKey = menu.module + ':' + menu.menuCode + ':' + action;

  if (!permissionService.hasPermission(userId, permissionKey)) {
    return 403;
  }

  // 继续执行业务逻辑
}
```

权限入库策略（可选）：
- 同步入库：在用户创建自定义菜单时，系统自动为每个允许的 action 生成 permission 记录并加入 permission 表，以便审计与集中管理。
- 延迟入库：首次请求时若 permission 不存在，动态生成并入库（同时创建审核记录）。优点：便捷；缺点：权限体系杂乱，建议配合管理员审核页面。

缓存与版本控制：
- menu 表保留 `version` 字段，权限变更时递增；用户端可返回 menuVersion 用于快速校验。服务端缓存 Menu 时同时缓存 version；在接收到带有 stale version 的请求时可拒绝或强制回源验证。
- 当管理员变更菜单定义或 action 列表时，发布消息通知清理相关 menu 与用户权限缓存（Redis Pub/Sub 或消息队列）。

安全考虑：
- 不要信任前端传入的 menuCode 或 menuName，必须以 menuId 为准并在服务端回查映射。
- 对于跨租户或共享菜单，必须校验 ownership/tenant 防止越权访问。
- 对高权限操作建议二次确认或额外的权限校验（如二次验证、审批流）。

示例：当统一 action 接口为 POST /api/action，前端请求体为 {menuId:123,action:'delete',payload:{...}}，后端通过上面逻辑拼装为 'order:custom-menu-001:delete' 并完成权限判断。


## 核心实现要点（Spring Boot 示例）
- Permission 实体、Repository（JPA 或 MyBatis）
- PermissionService：提供 loadUserPermissions(userId)（优先从 Redis 缓存），并提供 refreshUserPermissions(userId) 接口
- 前端调用 /api/auth/permissions?pageCode=xxx 返回当前用户该页面可操作的按钮 code 列表
- 对后端敏感接口使用注解拦截校验：
  - 方式A：使用 Spring Security 的 Method Security（@PreAuthorize("hasAuthority('order:order-list:add')")）
  - 方式B：自定义注解 @ButtonPermission("order:order-list:add") + AOP 切面校验 PermissionService

### 自定义注解示例
- 注解：@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ButtonPermission { String value(); }
- 切面：在调用前取出当前 userId -> permissionCache -> 判断是否包含注解 value，若不包含抛出 403

## 缓存策略
- 缓存存储：Redis，key: auth:permissions:user:{userId}
- 缓存粒度：按用户缓存整套权限（便于快速判断），并保存角色版本号/时间戳用于强制失效
- 缓存过期：默认 TTL 12 小时，权限变动时触发主动刷新
- 主动刷新：管理员修改角色或权限时，调用 /api/admin/permissions/refresh-cache 或者发布消息到消息队列（如 Redis Pub/Sub）通知所有网关/服务刷新相应用户缓存或角色级别缓存

## 权限管理前端契约
- 登录后前端请求 /api/auth/permissions?pageCode=xxx 获取按钮 code 列表
- 前端维护每个按钮的 code，渲染时检查按钮 code 是否存在于返回列表中

## 示例 SQL 数据
INSERT INTO `permission` (`code`,`name`,`module`,`menu_code`,`action`,`url`) VALUES
('order:order-list:view','订单列表-查看','order','order-list','view','/api/orders'),
('order:order-list:add','订单列表-新增','order','order-list','add','/api/orders'),
('order:order-list:delete','订单列表-删除','order','order-list','delete','/api/orders/{id}');

## 常见问题与建议
- 为什么既要前端显示控制，又要后端校验？
  前端显示仅为提升用户体验，任何重要操作必须后端二次校验以避免越权调用。
- 权限变化如何做到实时生效？
  使用 Redis Pub/Sub 或消息队列通知各服务删除/更新缓存，或在角色/权限变更接口中主动调用刷新 API。
- 性能考虑：
  - 推荐按用户缓存全部权限，权限判断时直接命中 Redis Set 或本地内存副本
  - 对高并发系统采用布隆过滤器或分桶缓存减少 DB 访问

## 接入步骤（简短）
1. 创建数据库表并初始化权限数据
2. 实现 PermissionService（缓存优先）并在用户登录时加载权限到缓存
3. 提供 /api/auth/permissions?pageCode 接口供前端页面获取本页面按钮权限
4. 在后端敏感方法上加注解或 Spring Security 权限标签进行保护
5. 在角色/权限变更时触发缓存刷新

## 小结
本文档提供了从数据模型、接口契约到实现要点的完整方案，适合在现有 Spring Boot 项目中接入按钮级权限控制。你可以按需选择 Spring Security 原生注解或自定义注解+切面来实现后端校验。
